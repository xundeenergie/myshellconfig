#!/bin/bash
#################################################################################################
# title         :git-myshellconfig-checkout                                                        #
# description   :checkout git detached HEAD                                                     #
# author        :Jakobus Schürz                                                                 #
# changes by    :Jakobus Schürz                                                                 #
# created       :17.01.2019                                                                     #
# updated       :                                                                               #
# version       :1.0                                                                            #
# usage         :./git-checkout 	                                                        #
# notes         :                                                                               #
#################################################################################################

[ -z "${SGIT+x}" ] && SGIT=git
MYSHELLCONFIG_LOGDIR="./logs"
MYSHELLCONFIG_LOGFILE="${MYSHELLCONFIG_LOGDIR}/git.log"
[ -d "${MYSHELLCONFIG_LOGDIR}" ] || mkdir -p "${MYSHELLCONFIG_LOGDIR}"
[ -z "${MYSHELLCONFIG_GIT_REMOTE_NAME:+x}" ] || export MYSHELLCONFIG_GIT_REMOTE_NAME=origin
[ -z "${MYSHELLCONFIG_GIT_BRANCH:+x}" ] || export MYSHELLCONFIG_GIT_BRANCH=master

cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"
+-----BEGINN $(date) -------------------------------+
EOF

case $1 in
    -h)
        # Headless repo local
        PRE="${MYSHELLCONFIG_GIT_REMOTE_NAME}"
        ;;
    *)
        PRE=""
        ;;
esac
# If TAG is set, checkout is always headless. 
[ -z "${MYSHELLCONFIG_GIT_TAG:+x}" ] || { export MYSHELLCONFIG_GIT_BRANCH=${MYSHELLCONFIG_GIT_TAG}; export PRE=""; }

# Output
echo -n " remote: ${MYSHELLCONFIG_GIT_REMOTE_NAME}, branch: ${MYSHELLCONFIG_GIT_BRANCH}: "

$SGIT fetch ${MYSHELLCONFIG_GIT_REMOTE_NAME} -p  2>>"${MYSHELLCONFIG_LOGFILE}"|| { echo fetch failed; exit 1; }

if $SGIT diff-index --ignore-submodules --exit-code HEAD -- >> "${MYSHELLCONFIG_LOGFILE}" ; then
    cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"
Check for local changes:
    no changes in local repo
    $SGIT checkout repo ${PRE}${PRE:+/}${MYSHELLCONFIG_GIT_BRANCH}
EOF
    #echo "checkout origin/master as detached HEAD"
    $SGIT checkout ${PRE}${PRE:+/}${MYSHELLCONFIG_GIT_BRANCH} 1>>"${MYSHELLCONFIG_LOGFILE}" 2>>"${MYSHELLCONFIG_LOGFILE}"|| exit 2
    $SGIT merge FETCH_HEAD 1>>"${MYSHELLCONFIG_LOGFILE}" 2>>"${MYSHELLCONFIG_LOGFILE}"|| exit 3
else
    cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"
Check for local changes:
    Ich habe lokale Änderungen festgestellt
    um die Änderung zurückzusetzen bitte

      $SGIT checkout \$FILENAME

    oder um alle lokalen Änderungen auf einmal zurückzusetzen:

      $SGIT checkout .

    ausführen

    Die Änderungen sind:
EOF
    $SGIT diff-index HEAD --|awk '{print $5, $6}' >>  "${MYSHELLCONFIG_LOGFILE}"
    $SGIT diff-index -p HEAD -- >> "${MYSHELLCONFIG_LOGFILE}"

    echo "Lokale Änderungen festgestellt: Siehe Logfile ${MYSHELLCONFIG_LOGFILE}" >&2
cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"

+-----ENDE $(date) ---------------------------------+
 
EOF
    exit 4

fi

cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"

+-----update submodules $(date) ---------------------------------+
 
EOF
rc=0
## Update/init submodules
#$SGIT submodule update --remote --merge 2>>"${MYSHELLCONFIG_LOGFILE}"|| { echo update submodules failed: continue ; }
#$SGIT submodule init 1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo update submodules failed; exit 1; }
#$SGIT submodule sync 1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo sync submodules failed; exit 1; }
#$SGIT submodule foreach "$SGIT branch -u origin/master master"  1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo set-upstream submodules failed; exit 1; }
#$SGIT submodule update --recursive --remote --merge 1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo update submodules failed; exit 1; }

#echo "update submodules" >&2
# Submodules always have origin and master as repo and branch to track
$SGIT submodule init 1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo update submodules failed on ini; rc=5; }
$SGIT submodule sync 1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo sync submodules failed on sync; rc=6;  }
$SGIT submodule foreach "git checkout master"  1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo checkout master submodules failed on set upstream; rc=7;  }
$SGIT submodule foreach "git branch -u origin/master master"  1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo set-upstream submodules failed on set upstream; rc=8;  }
$SGIT submodule update --recursive --remote --merge 1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1|| { echo update submodules failed on update; rc=9;  }
#echo "submodules updated" >&2

cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"

+-----ENDE $(date) ---------------------------------+
 
EOF
exit $rc

