#!/bin/bash
#debug

failure() {
  local lineno=$1
  local msg=$2
  echo "Failed at $lineno: $msg"
}
trap 'failure ${LINENO} "$BASH_COMMAND"' ERR


# set SSHS to false, if not set
if [ -z ${SSHS+x} ]; then export SSHS=false;fi

# define debug default
MYSHELLCONFIG_DEBUG_DEFAULT=false
# set debug to default, if not set
if [ -z ${MYSHELLCONFIG_DEBUG+x} ]; then export MYSHELLCONFIG_DEBUG=$MYSHELLCONFIG_DEBUG_DEFAULT;fi

turnondebug() {
    change_debug true
}

turnoffdebug() {
    change_debug false
}

change_debug () {
    if $1; then
        echo turn ON debug myshellconfig
        export MYSHELLCONFIG_DEBUG=true
    else
        echo turn OFF debug myshellconfig
        export MYSHELLCONFIG_DEBUG=false
    fi
}


# check if we are a interactive shell
# https://guide.bash.academy/expansions/
# https://www.tldp.org/LDP/abs/html/refcards.html#AEN22473
if [[ $- = *i* ]] ; then
    #echo "interactive shell" >&2

    # define variables
    # default timeouts defined in myshellconfig_load_default
    #[ -z "${MYSHELLCONFIG_ROOT_TMOUT+x}" ]  && MYSHELLCONFIG_ROOT_TMOUT=500
    #[ -z "${MYSHELLCONFIG_USER_TMOUT+x}" ]  && MYSHELLCONFIG_USER_TMOUT=0
    [ -z "${USERNAME+x}" ]                              && export USERNAME="$USER"
    [ -z "${USEREMAIL+x}" ]                             && export USEREMAIL="$USER@$(domainname -d)"
    [ -z "${FULLNAME+x}" ]                              && export FULLNAME="$(getent passwd $USER | cut -d ":" -f 5 | cut -d ',' -f 1)"
    [ -z "${GIT_AUTHOR_NAME+x}" ]                       && export GIT_AUTHOR_NAME=$FULLNAME
    [ -z "${GIT_AUTHOR_EMAIL+x}" ]                      && export GIT_AUTHOR_EMAIL=$USEREMAIL
    [ -z "${GIT_COMMITTER_NAME+x}" ]                    && export GIT_COMMITTER_NAME=$FULLNAME
    [ -z "${GIT_COMMITTER_EMAIL+x}" ]                   && export GIT_COMMITTER_EMAIL=$USEREMAIL

    [ -z "${MYSHELLCONFIG_SUBPATH+x}" ]                 && MYSHELLCONFIG_SUBPATH=".local/myshellconfig"
    [ -z "${MYSHELLCONFIG_BASE+x}" ]                    && export MYSHELLCONFIG_BASE="${HOME}/${MYSHELLCONFIG_SUBPATH}"
    MYSHELLCONFIG_BASE_PARENT="$(dirname $MYSHELLCONFIG_BASE)"
    [ -z "${MYSHELLCONFIG_LOGDIR+x}" ]                  && export MYSHELLCONFIG_LOGDIR="${MYSHELLCONFIG_BASE}/logs"
    [ -z "${MYSHELLCONFIG_LOGFILE+x}" ]                 && export MYSHELLCONFIG_LOGFILE="${MYSHELLCONFIG_LOGDIR}/myshellconfig.log"
    [ -z "${MYSHELLCONFIG_GIT_TIMEOUT+x}" ]             && MYSHELLCONFIG_GIT_TIMEOUT=5s
    [ -z "${MYSHELLCONFIG_GIT_CHECKOUT_TIMEOUT+x}" ]    && MYSHELLCONFIG_GIT_CHECKOUT_TIMEOUT=20s
    MYSHELLCONFIG_BASH_COMPLETION="${HOME}/${MYSHELLCONFIG_SUBPATH}/bash_completion.d"
    [ -z "${MYSHELLCONFIG_GIT_SYNC+x}" ]                && MYSHELLCONFIG_GIT_SYNC=true


    export SGIT="git -C ${MYSHELLCONFIG_BASE}" 
    export MYSHELLCONFIG_VIM_PLUGINS

    # Create necessary directories
    [ -n "${MYSHELLCONFIG_LOGDIR-x}" ] && mkdir -p "$MYSHELLCONFIG_LOGDIR"

    cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"
    ------- start -------------- $(date) ---------------8<--

EOF
    # define functions
    ckrepo () {
        # check if remote repo is reachable
        if $MYSHELLCONFIG_GIT_SYNC; then
            if $( timeout --foreground "${MYSHELLCONFIG_GIT_TIMEOUT}"  $SGIT ls-remote >/dev/null  2>&1) ;then 
                return 0
            else 
                return 1
            fi
        else
            echo "no sync allowed from config" >&2
            return 0
        fi

    }

    sync_config () {
        if $MYSHELLCONFIG_GIT_SYNC; then
            local nok=""
            local gco=""
            if which git >/dev/null; then
                echo -n "Sync config with ${MYSHELLCONFIG_GIT_SERVER}: " 1>&2
                # MYSHELLCONFIG_GITCHECKOUTSCRIPT_OPTIONS are options for bin/git-myshellconfig-checkout
                if [ -z ${MYSHELLCONFIG_GIT_CHECKOUTSCRIPT_OPTIONS+x} ]; then
                    gco="-h"
                else
                    gco="$MYSHELLCONFIG_GIT_CHECKOUTSCRIPT_OPTIONS"
                fi
                ${MYSHELLCONFIG_BASE}/bin/git-myshellconfig-checkout ${gco}|| nok="not " 1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1 
                printf '%s\n' "${nok}synced" 1>&2
                [ -z "$nok"  ] && mkdir -pv "${MYSHELLCONFIG_LOGDIR}"

            else
                echo "git not installed, no configuration possible, please install git" >&2
            fi
        else
            echo "Not syncing profile in case of configuration"
        fi
    }

    # Check for interactive bash and that we haven't already been sourced.
    if [ -n "${BASH_VERSION-}" -a -n "${PS1-}" -a -z "${BASH_COMPLETION_VERSINFO-}" ]; then

        # Check for recent enough version of bash.
        if [ ${BASH_VERSINFO[0]} -gt 4 ] || \
           [ ${BASH_VERSINFO[0]} -eq 4 -a ${BASH_VERSINFO[1]} -ge 1 ]; then
            [ -r "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion" ] && \
                . "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion"
            if shopt -q progcomp && [ -r /usr/share/bash-completion/bash_completion ]; then
                # Source completion code.
                echo "Source bash-completion"
                . /usr/share/bash-completion/bash_completion
            fi
        fi

    fi


    # source git-sync part of myshellconfig
    . "${MYSHELLCONFIG_BASE}/myshell_git_sync"

    # source loading defaults part of myshellconfig
    . "${MYSHELLCONFIG_BASE}/myshell_load_defaults"

    # source loading workaround for x2go to forward local etoken to remote machine with forwardagent
    . "${MYSHELLCONFIG_BASE}/myshell_load_x2go_tokenforward"

  
    cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"
    --8<--- end ---------------- $(date) ---------------8<--

EOF
#else
#    echo "non-interactive shell" >&2
fi

