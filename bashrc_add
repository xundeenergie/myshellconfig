#!/bin/bash
#debug

#failure() {
#  local lineno=$1
#  local msg=$2
#  echo "Failed at $lineno: $msg"
#}
#trap 'failure ${LINENO} "$BASH_COMMAND"' ERR


# set some variables to defaults, if not set in .bashrc
[ -z ${SSHS+x} ] && export SSHS=false
[ -z ${STARTTMUX+x} ] && export STARTTMUX=false

# check if we are a interactive shell
# https://guide.bash.academy/expansions/
# https://www.tldp.org/LDP/abs/html/refcards.html#AEN22473
if [[ $- = *i* ]] ; then
    #echo "interactive shell" >&2

    # define variables
    # Base Path
    [ -z "${MYSHELLCONFIG_SUBPATH+x}" ]                 && export MYSHELLCONFIG_SUBPATH=".local/myshellconfig"
    [ -z "${MYSHELLCONFIG_BASE+x}" ]                    && export MYSHELLCONFIG_BASE="${HOME}/${MYSHELLCONFIG_SUBPATH}"
    # hardcoded paths
    export MYSHELLCONFIG_BASE_PARENT="$(dirname $MYSHELLCONFIG_BASE)"
    export MYSHELLCONFIG_BASH_COMPLETION="${HOME}/${MYSHELLCONFIG_SUBPATH}/bash_completion.d"

    # Userdata
    [ -z "${USERNAME+x}" ]                              && export USERNAME="$USER"
    [ -z "${USEREMAIL+x}" ]                             && export USEREMAIL="$USER@$(domainname -d)"
    [ -z "${FULLNAME+x}" ]                              && export FULLNAME="$(getent passwd $USER | cut -d ":" -f 5 | cut -d ',' -f 1)"
    
    # GIT
    [ -z "${GIT_AUTHOR_NAME+x}" ]                               && export GIT_AUTHOR_NAME=$FULLNAME
    [ -z "${GIT_AUTHOR_EMAIL+x}" ]                              && export GIT_AUTHOR_EMAIL=$USEREMAIL
    [ -z "${GIT_COMMITTER_NAME+x}" ]                            && export GIT_COMMITTER_NAME=$FULLNAME
    [ -z "${GIT_COMMITTER_EMAIL+x}" ]                           && export GIT_COMMITTER_EMAIL=$USEREMAIL
    [ -z "${MYSHELLCONFIG_GIT_TIMEOUT+x}" ]                     && export MYSHELLCONFIG_GIT_TIMEOUT=5s
    [ -z "${MYSHELLCONFIG_GIT_CHECKOUT_TIMEOUT+x}" ]            && export MYSHELLCONFIG_GIT_CHECKOUT_TIMEOUT=20s
    [ -z "${MYSHELLCONFIG_GIT_SYNC+x}" ]                        && export MYSHELLCONFIG_GIT_SYNC=true
    [ -z "${MYSHELLCONFIG_GIT_SUBMODULES_UPDATE_DEFAULT+x}" ]   && export MYSHELLCONFIG_GIT_SUBMODULES_UPDATE_DEFAULT=true
    [ -z "${MYSHELLCONFIG_GIT_SUBMODULES_UPDATE_INTERVALL+x}" ] && export MYSHELLCONFIG_GIT_SUBMODULES_UPDATE_INTERVALL=48 #intervall in hours
    [ -z "${MYSHELLCONFIG_GIT_SUBMODULES_SERVER_DEFAULT+x}" ]   && export MYSHELLCONFIG_GIT_SUBMODULES_SERVER_DEFAULT="git://git.schuerz.at/github.com/"
    # hardcoded git
    export SGIT="git -C ${MYSHELLCONFIG_BASE}" 


    
    # git-repo-url for vim plugin
    # TODO: check how to use
    export MYSHELLCONFIG_VIM_PLUGINS


    # Logging
    [ -z "${MYSHELLCONFIG_LOGDIR+x}" ]                  && export MYSHELLCONFIG_LOGDIR="${HOME}/logs"
    [ -z "${MYSHELLCONFIG_LOGFILE+x}" ]                 && export MYSHELLCONFIG_LOGFILE="${MYSHELLCONFIG_LOGDIR}/myshellconfig.log"
    [ -z "${MYHSELLCONFIG_LOGLEVEL_DEFAULT+x}" ]        && export MYHSELLCONFIG_LOGLEVEL_DEFAULT="INFO"
    [ -z "${MYHSELLCONFIG_FILELOGLEVEL_DEFAULT+x}" ]    && export MYHSELLCONFIG_FILELOGLEVEL_DEFAULT="DEBUG"
    [ -z "${SCRIPT_LOG+x}" ]                            && export SCRIPT_LOG="${MYSHELLCONFIG_LOGFILE}"
    [ -z "${LOGLEVEL_DEFAULT+x}" ]                      && export LOGLEVEL_DEFAULT="${MYHSELLCONFIG_LOGLEVEL_DEFAULT-INFO}"
    [ -z "${FILELOGLEVEL_DEFAULT+x}" ]                  && export FILELOGLEVEL_DEFAULT="${MYHSELLCONFIG_FILELOGLEVEL_DEFAULT-INFO}"
    # Create necessary directories for logging
    [ -n "${MYSHELLCONFIG_LOGDIR-x}" ] && mkdir -p "$MYSHELLCONFIG_LOGDIR"
    # load logging functions
    . ${MYSHELLCONFIG_BASE}/logging

    # PKCS11_MODULE for etoken/smartcard authentification
    [ -n "$(whereis p11-kit-proxy.so|awk '{print $2}')" ] && PKCS11_MODULE=$(whereis p11-kit-proxy.so|awk '{print $2}')

    # Basics
    [ -z "${VISUAL+x}" ]    && export VISUAL=vim
    [ -z "${EDITOR+x}" ]    && export EDITOR=vim

    cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"
==8<=== start configure new shell ============== $(date) ===============8<==

EOF

    SCRIPTENTRY
    # define functions
    ckrepo () {
        # check if remote repo is reachable
        if $MYSHELLCONFIG_GIT_SYNC; then
            if $( timeout --foreground "${MYSHELLCONFIG_GIT_TIMEOUT}"  $SGIT ls-remote >/dev/null  2>&1) ;then 
                return 0
            else 
                return 1
            fi
        else
            logwarn "no sync allowed from config" >&2
            return 0
        fi

    }

    sync_config () {
        if $MYSHELLCONFIG_GIT_SYNC; then
            local nok=""
            local gco=""
            if which git >/dev/null; then
                loginfo -n "Sync config with ${MYSHELLCONFIG_GIT_SERVER}: " 
                # MYSHELLCONFIG_GITCHECKOUTSCRIPT_OPTIONS are options for bin/git-myshellconfig-checkout
                if [ -z ${MYSHELLCONFIG_GIT_CHECKOUTSCRIPT_OPTIONS+x} ]; then
                    gco="-h"
                else
                    gco="$MYSHELLCONFIG_GIT_CHECKOUTSCRIPT_OPTIONS"
                fi
                ${MYSHELLCONFIG_BASE}/bin/git-myshellconfig-checkout ${gco}|| nok="not " 1>>"${MYSHELLCONFIG_LOGFILE}" 2>&1 
                loginfo "$(printf '%s\n' "${nok}synced" )"
                [ -z "$nok"  ] && mkdir -pv "${MYSHELLCONFIG_LOGDIR}"

            else
                logwarn "git not installed, no configuration possible, please install git" >&2
            fi
        else
            logwarn "Not syncing profile in case of configuration"
        fi
    }


    pathmunge () {
        ENTRY
        case ":${PATH}:" in
            *:"$1":*)
                ;;
            *)
                if [ "$2" = "after" ] ; then
                    PATH=$PATH:$1
                else
                    PATH=$1:$PATH
                fi
        esac
        EXIT
    }

    if [ -d "${MYSHELLCONFIG_BASE}/bin" ] ; then
        pathmunge "${MYSHELLCONFIG_BASE}/bin"
        export PATH
    fi

    if [ -d "${HOME}/.local/bin" ] ; then
        pathmunge "${HOME}/.local/bin"
        export PATH
    fi

    # Check for interactive bash and that we haven't already been sourced.
    if [ -n "${BASH_VERSION-}" -a -n "${PS1-}" -a -z "${BASH_COMPLETION_VERSINFO-}" ]; then

        # Check for recent enough version of bash.
        if [ ${BASH_VERSINFO[0]} -gt 4 ] || \
           [ ${BASH_VERSINFO[0]} -eq 4 -a ${BASH_VERSINFO[1]} -ge 1 ]; then
            [ -r "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion" ] && \
                . "${XDG_CONFIG_HOME:-$HOME/.config}/bash_completion"
            if shopt -q progcomp && [ -r /usr/share/bash-completion/bash_completion ]; then
                # Source completion code.
                logdebug "Source bash-completion"
                . /usr/share/bash-completion/bash_completion
            fi
        fi

    fi

    # source git-sync part of myshellconfig
    . "${MYSHELLCONFIG_BASE}/myshell_git_sync"

    # source loading defaults part of myshellconfig
    . "${MYSHELLCONFIG_BASE}/myshell_load_defaults"

    # source loading workaround for x2go to forward local etoken to remote machine with forwardagent
    . "${MYSHELLCONFIG_BASE}/myshell_load_x2go_tokenforward"

    promptcommandmunge "_tmux_hook"
    promptcommandmunge "_umask_hook"
    which direnv >/dev/null && eval "$(direnv hook bash)"
  
    cat << EOF >> "${MYSHELLCONFIG_LOGFILE}"
==8<=== finished configure new shell ================ $(date) ===============8<==

EOF
#else
#    echo "non-interactive shell" >&2
    SCRIPTEXIT

    # Start tmux if not defined as STARTTMUX in bashrc
    logdebug "start tmux ${STARTTMUXDEFAULT}Â - ${STARTTMUXDEFAULT-$STARTTMUX}"
    if ${STARTTMUXDEFAULT-$STARTTMUX} ; then
        cat << EOF

"User: $USER - $UID"

Starting or resuming screen session
Press CTRL+C to cancel screen startup

EOF
        sleep 1
        #screen -UxR
        tmux attach-session
        logdebug "started tmux"
    fi
    logdebug "after"

fi
